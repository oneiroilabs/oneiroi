use std::{any::Any, fmt::Debug, sync::RwLock};

use control_flow::{socket_input::SocketInputV1, socket_output::SocketOutputV1};
use modifiers::extrude::ExtrudeV1;
use producers::{r#box::BoxV1, cylinder::CylinderV1};
use serde::{Deserialize, Serialize};

use crate::{
    asset::{
        Asset,
        instance::{self, AssetInstance},
    },
    data_types::{DataTypeInstance, DataTypeType, PropertyMetadata},
    mesh::OneiroiMesh,
};

pub mod control_flow;
//pub mod instance;
pub mod modifiers;
pub mod producers;

pub trait PropertyInterface {
    fn try_set_property(&mut self, property: &str, value: DataTypeInstance) -> Result<(), ()>;
    fn try_get_property(&self, property: &str) -> Result<DataTypeInstance, ()>;
    fn get_properties(&self) -> Vec<PropertyMetadata>;
}

pub trait Operation: PropertyInterface {
    //TODO this should most likely take a slice
    fn compute(&self, input_sockets: Vec<&DataTypeInstance>) -> Vec<DataTypeInstance>;

    /* //These 4 methods can be generated by a proc macro with the exception of Handlers aka AssetInstance
    fn try_set_property(
        &mut self,
        property: &str,
        value: DataTypeInstance,
        context: Option<&AssetInstance>,
    ) -> Result<(), ()>;
    fn try_get_property(&self, property: &str) -> Result<DataTypeInstance, ()>;
    fn get_properties(&self) -> Vec<PropertyMetadata>; */
    //TODO switch to slices or iterators most likely
    fn get_sockets(&self) -> (Vec<DataTypeType>, Vec<DataTypeType>) {
        (self.get_input_sockets(), self.get_output_sockets())
    }
    fn get_input_sockets(&self) -> Vec<DataTypeType>;
    fn get_output_sockets(&self) -> Vec<DataTypeType>;

    //#[cfg(not(feature = "only_runtime"))]
    //TODO proper error handling and all cases
    /* fn verify_sockets(&self, input_sockets: Vec<&DataTypeInstance>) -> Result<(), ()> {
        for (index, input) in self.get_sockets().0.iter().enumerate() {
            match input {
                DataTypeType::Omni => return Err(()),
                DataTypeType::Mesh => input_sockets[index]
                    .ge::<OneiroiMesh>()
                    .ok_or_else(|| ()),
                DataTypeType::Collection => todo!(),
                DataTypeType::Instance => todo!(),
                DataTypeType::Curve => todo!(),
                DataTypeType::Collider => todo!(),
                DataTypeType::Vec3 => todo!(),
                DataTypeType::Int => todo!(),
                DataTypeType::Float => todo!(),
                DataTypeType::Curve2d => todo!(),
                DataTypeType::Bool => todo!(),
            };
        }
        Ok(())
    } */

    fn static_metadata(&self) -> StaticNodeMetadata;
}

//Since the enum is tagged in serde we can erase the versioning for the Nodes enum
#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum Nodes {
    //Internal
    Expose, //Only 1 of this should be in the graph root and edges to it indicate Exposed Variables

    //Producers
    BoxV1(Box<BoxV1>),
    CylinderV1(Box<CylinderV1>),

    //Modifiers
    ExtrudeV1(Box<ExtrudeV1>),

    //Transformers

    //Control Flow
    SocketInput(Box<SocketInputV1>),
    SocketOutput(Box<SocketOutputV1>),

    //Asset
    EmbeddedAsset(Box<AssetInstance>),
}

pub struct StaticNodeMetadata {
    pub color: &'static str,
}

impl Nodes {
    pub fn get_node_types() {} //TODO

    pub fn is_output_node(&self) -> bool {
        matches!(self, Nodes::SocketOutput(_))
    }

    pub(crate) fn get_embedded_instance(&mut self) -> &mut AssetInstance {
        match self {
            Nodes::EmbeddedAsset(instance) => instance,
            _ => panic!(),
        }
    }

    //pub fn get_static_metadata(&self) -> StaticNodeMetadata {

    pub(crate) fn from_alias(alias: &str) -> Self {
        match alias {
            "Box" => Nodes::BoxV1(Box::default()),
            "Cylinder" => Nodes::CylinderV1(Box::default()),
            "Extrude" => Nodes::ExtrudeV1(Box::default()),
            "Output" => Nodes::SocketOutput(Box::default()),
            _ => panic!("This should not panic but instead return an error"),
        }
    }
}

impl PropertyInterface for Nodes {
    fn try_set_property(&mut self, property: &str, value: DataTypeInstance) -> Result<(), ()> {
        match self {
            Nodes::Expose => unimplemented!(),
            Nodes::BoxV1(box_v1) => box_v1.try_set_property(property, value),
            Nodes::ExtrudeV1(extrude_v1) => extrude_v1.try_set_property(property, value),
            Nodes::SocketInput(socket_input_v1) => todo!(),
            Nodes::SocketOutput(socket_output_v1) => {
                socket_output_v1.try_set_property(property, value)
            }
            Nodes::EmbeddedAsset(asset_instance) => {
                asset_instance.try_set_property(property, value)
            }
            Nodes::CylinderV1(cylinder_v1) => cylinder_v1.try_set_property(property, value),
        }
    }

    fn try_get_property(&self, property: &str) -> Result<DataTypeInstance, ()> {
        match self {
            Nodes::Expose => unimplemented!(),
            Nodes::BoxV1(box_v1) => box_v1.try_get_property(property),
            Nodes::ExtrudeV1(extrude_v1) => extrude_v1.try_get_property(property),
            Nodes::SocketInput(socket_input_v1) => todo!(),
            Nodes::SocketOutput(socket_output_v1) => socket_output_v1.try_get_property(property),
            Nodes::EmbeddedAsset(asset_instance) => asset_instance.try_get_property(property),
            Nodes::CylinderV1(cylinder_v1) => cylinder_v1.try_get_property(property),
        }
    }

    fn get_properties(&self) -> Vec<PropertyMetadata> {
        match self {
            Nodes::Expose => unimplemented!(),
            Nodes::BoxV1(box_v1) => box_v1.get_properties(),
            Nodes::ExtrudeV1(extrude_v1) => extrude_v1.get_properties(),
            Nodes::SocketInput(socket_input_v1) => todo!(),
            Nodes::SocketOutput(socket_output_v1) => socket_output_v1.get_properties(),
            Nodes::EmbeddedAsset(asset_instance) => asset_instance.get_properties(),
            Nodes::CylinderV1(cylinder_v1) => cylinder_v1.get_properties(),
        }
    }
}

impl Operation for Nodes {
    //type InputSockets = ();

    //type OutputSockets = ();

    fn compute(&self, input_sockets: Vec<&DataTypeInstance>) -> Vec<DataTypeInstance> {
        //check the sockets.
        match self {
            Nodes::Expose => unimplemented!(),
            Nodes::BoxV1(box_v1) => {
                //TODO dispatch
                box_v1.compute(input_sockets)
            }
            Nodes::ExtrudeV1(extrude_v1) => {
                //let huh: OneiroiMesh = huh;
                //Oneiroi_extrude_v1.compute(huh[0].clone())
                extrude_v1.compute(input_sockets)
            }
            Nodes::SocketInput(_) => unimplemented!(),
            Nodes::SocketOutput(_) => unimplemented!(),
            Nodes::EmbeddedAsset(asset_template) => asset_template.compute(input_sockets),
            Nodes::CylinderV1(cylinder_v1) => cylinder_v1.compute(vec![]),
        }
    }

    /* fn parse_sockets(input_sockets: Vec<&DataTypeInstance>) -> Result<Self::InputSockets, ()> {
        todo!()
    } */

    /* fn get_sockets(&self) -> (Vec<DataTypeType>, Vec<DataTypeType>) {
        match self {
            Nodes::Expose => todo!(),
            Nodes::BoxV1(box_v1) => box_v1.get_sockets(),
            Nodes::ExtrudeV1(extrude_v1) => extrude_v1.get_sockets(),
            Nodes::SocketInput(socket_input_v1) => todo!(),
            Nodes::SocketOutput(socket_output_v1) => socket_output_v1.get_sockets(),
            Nodes::EmbeddedAsset(asset_template) => asset_template.get_sockets(),
            Nodes::CylinderV1(cylinder_v1) => cylinder_v1.get_sockets(),
        }
    } */

    fn get_output_sockets(&self) -> Vec<DataTypeType> {
        match self {
            Nodes::Expose => unimplemented!(),
            Nodes::BoxV1(box_v1) => box_v1.get_output_sockets(),
            Nodes::ExtrudeV1(extrude_v1) => extrude_v1.get_output_sockets(),
            Nodes::SocketInput(socket_input_v1) => todo!(),
            Nodes::SocketOutput(socket_output_v1) => socket_output_v1.get_output_sockets(),
            Nodes::EmbeddedAsset(asset_template) => asset_template.get_output_sockets(),
            Nodes::CylinderV1(cylinder_v1) => cylinder_v1.get_output_sockets(),
        }
    }

    fn get_input_sockets(&self) -> Vec<DataTypeType> {
        match self {
            Nodes::Expose => unimplemented!(),
            Nodes::BoxV1(box_v1) => box_v1.get_input_sockets(),
            Nodes::ExtrudeV1(extrude_v1) => extrude_v1.get_input_sockets(),
            Nodes::SocketInput(socket_input_v1) => todo!(),
            Nodes::SocketOutput(socket_output_v1) => socket_output_v1.get_input_sockets(),
            Nodes::EmbeddedAsset(asset_template) => asset_template.get_input_sockets(),
            Nodes::CylinderV1(cylinder_v1) => cylinder_v1.get_input_sockets(),
        }
    }

    fn static_metadata(&self) -> StaticNodeMetadata {
        match self {
            Nodes::Expose => unimplemented!(),
            Nodes::BoxV1(var) => var.static_metadata(),
            Nodes::CylinderV1(var) => var.static_metadata(),
            Nodes::ExtrudeV1(var) => var.static_metadata(),
            Nodes::SocketInput(var) => todo!(),
            Nodes::SocketOutput(var) => var.static_metadata(),
            Nodes::EmbeddedAsset(var) => var.static_metadata(),
        }
    }
}
